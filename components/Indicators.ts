'use client';export type Indicators={ema20?:number;ema60?:number;rsi14?:number;vol30?:number;z30?:number;signal?:'A_outperforms'|'neutral'|'B_outperforms'};function e(a:number[],p:number){if(a.length===0)return;const k=2/(p+1);let x=a[0];for(let i=1;i<a.length;i++)x=a[i]*k+x*(1-k);return x}function r(v:number[],p=14){if(v.length<p+1)return;let g=0,l=0;for(let i=1;i<=p;i++){const d=v[i]-v[i-1];if(d>=0)g+=d;else l-=d}let G=g/p,L=l/p;for(let i=p+1;i<v.length;i++){const d=v[i]-v[i-1];G=(G*(p-1)+Math.max(d,0))/p;L=(L*(p-1)+Math.max(-d,0))/p}if(L===0)return 100;const rs=G/L;return 100-100/(1+rs)}function s(a:number[]){if(a.length<2)return;const m=a.reduce((x,y)=>x+y,0)/a.length;const v=a.reduce((x,y)=>x+(y-m)**2,0)/(a.length-1);return Math.sqrt(v)}export function computeIndicators(ratios:number[]){const ema20=e(ratios.slice(-100),20),ema60=e(ratios.slice(-300),60),rsi14=r(ratios.slice(-200),14),last=ratios.slice(-30),vol30=s(last);let z30; if(last.length>=2){const mean=last.reduce((x,y)=>x+y,0)/last.length,sd=s(last)!;if(sd&&sd>0)z30=(last[last.length-1]-mean)/sd}let signal:'A_outperforms'|'neutral'|'B_outperforms'='neutral';if(ema20&&ema60&&rsi14){if(ema20>ema60&&rsi14>55)signal='A_outperforms';else if(ema20<ema60&&rsi14<45)signal='B_outperforms'}return{ema20,ema60,rsi14,vol30,z30,signal}}